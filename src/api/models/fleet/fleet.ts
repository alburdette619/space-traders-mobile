/**
 * Generated by orval v8.0.0-rc.1 üç∫
 * Do not edit manually.
 * SpaceTraders API
 * SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.

The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.

```json http
{
  "method": "GET",
  "url": "https://api.spacetraders.io/v2",
}
```

Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.

We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.



 * OpenAPI spec version: 2.3.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { useMutation, useQuery } from '@tanstack/react-query';

import type { ErrorType } from '../../client';
import type { CreateChart201 } from '../createChart201';
import type { CreateShipShipScan201 } from '../createShipShipScan201';
import type { CreateShipSystemScan201 } from '../createShipSystemScan201';
import type { CreateShipWaypointScan201 } from '../createShipWaypointScan201';
import type { CreateSurvey201 } from '../createSurvey201';
import type { DockShip200 } from '../dockShip200';
import type { ExtractResources201 } from '../extractResources201';
import type { ExtractResourcesBody } from '../extractResourcesBody';
import type { ExtractResourcesWithSurvey201 } from '../extractResourcesWithSurvey201';
import type { GetMounts200 } from '../getMounts200';
import type { GetMyShip200 } from '../getMyShip200';
import type { GetMyShipCargo200 } from '../getMyShipCargo200';
import type { GetMyShips200 } from '../getMyShips200';
import type { GetMyShipsParams } from '../getMyShipsParams';
import type { GetRepairShip200 } from '../getRepairShip200';
import type { GetScrapShip200 } from '../getScrapShip200';
import type { GetShipCooldown200 } from '../getShipCooldown200';
import type { GetShipModules200 } from '../getShipModules200';
import type { GetShipNav200 } from '../getShipNav200';
import type { InstallMount201 } from '../installMount201';
import type { InstallMountBody } from '../installMountBody';
import type { InstallShipModule201 } from '../installShipModule201';
import type { InstallShipModuleBody } from '../installShipModuleBody';
import type { Jettison200 } from '../jettison200';
import type { JettisonBody } from '../jettisonBody';
import type { JumpShip200 } from '../jumpShip200';
import type { JumpShipBody } from '../jumpShipBody';
import type { Survey } from '../models-Survey/survey';
import type { NavigateShip200 } from '../navigateShip200';
import type { NavigateShipBody } from '../navigateShipBody';
import type { NegotiateContract201 } from '../negotiateContract201';
import type { OrbitShip200 } from '../orbitShip200';
import type { PatchShipNav200 } from '../patchShipNav200';
import type { PatchShipNavBody } from '../patchShipNavBody';
import type { PurchaseCargo201 } from '../purchaseCargo201';
import type { PurchaseCargoBody } from '../purchaseCargoBody';
import type { PurchaseShip201 } from '../purchaseShip201';
import type { PurchaseShipBody } from '../purchaseShipBody';
import type { RefuelShip200 } from '../refuelShip200';
import type { RefuelShipBody } from '../refuelShipBody';
import type { RemoveMount201 } from '../removeMount201';
import type { RemoveMountBody } from '../removeMountBody';
import type { RemoveShipModule201 } from '../removeShipModule201';
import type { RemoveShipModuleBody } from '../removeShipModuleBody';
import type { RepairShip200 } from '../repairShip200';
import type { ScrapShip200 } from '../scrapShip200';
import type { SellCargo201 } from '../sellCargo201';
import type { SellCargoBody } from '../sellCargoBody';
import type { ShipRefine201 } from '../shipRefine201';
import type { ShipRefineBody } from '../shipRefineBody';
import type { SiphonResources201 } from '../siphonResources201';
import type { TransferCargo200 } from '../transferCargo200';
import type { TransferCargoBody } from '../transferCargoBody';
import type { WarpShip200 } from '../warpShip200';
import type { WarpShipBody } from '../warpShipBody';

import { clientInstance } from '../../client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Return a paginated list of all of ships under your agent's ownership.
 * @summary List Ships
 */
export const getMyShips = (
  params?: GetMyShipsParams,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetMyShips200>(
    { method: 'GET', params, signal, url: `/my/ships` },
    options,
  );
};

export const getGetMyShipsQueryKey = (params?: GetMyShipsParams) => {
  return [`/my/ships`, ...(params ? [params] : [])] as const;
};

export const getGetMyShipsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyShips>>,
  TError = ErrorType<unknown>,
>(
  params?: GetMyShipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShips>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyShipsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyShips>>> = ({
    signal,
  }) => getMyShips(params, requestOptions, signal);

  return { queryFn, queryKey, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyShips>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyShipsQueryError = ErrorType<unknown>;
export type GetMyShipsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyShips>>
>;

export function useGetMyShips<
  TData = Awaited<ReturnType<typeof getMyShips>>,
  TError = ErrorType<unknown>,
>(
  params: GetMyShipsParams | undefined,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShips>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyShips>>,
          TError,
          Awaited<ReturnType<typeof getMyShips>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyShips<
  TData = Awaited<ReturnType<typeof getMyShips>>,
  TError = ErrorType<unknown>,
>(
  params?: GetMyShipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShips>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyShips>>,
          TError,
          Awaited<ReturnType<typeof getMyShips>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyShips<
  TData = Awaited<ReturnType<typeof getMyShips>>,
  TError = ErrorType<unknown>,
>(
  params?: GetMyShipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShips>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Ships
 */

export function useGetMyShips<
  TData = Awaited<ReturnType<typeof getMyShips>>,
  TError = ErrorType<unknown>,
>(
  params?: GetMyShipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShips>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMyShipsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Purchase a ship from a Shipyard. In order to use this function, a ship under your agent's ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type of the desired ship.

Shipyards typically offer ship types, which are predefined templates of ships that have dedicated roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a few modules and mounts.
 * @summary Purchase Ship
 */
export const purchaseShip = (
  purchaseShipBody: PurchaseShipBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<PurchaseShip201>(
    {
      data: purchaseShipBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships`,
    },
    options,
  );
};

export const getPurchaseShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof purchaseShip>>,
    TError,
    { data: PurchaseShipBody },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof purchaseShip>>,
  TError,
  { data: PurchaseShipBody },
  TContext
> => {
  const mutationKey = ['purchaseShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof purchaseShip>>,
    { data: PurchaseShipBody }
  > = (props) => {
    const { data } = props ?? {};

    return purchaseShip(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PurchaseShipMutationBody = PurchaseShipBody;
export type PurchaseShipMutationError = ErrorType<unknown>;
export type PurchaseShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof purchaseShip>>
>;

/**
 * @summary Purchase Ship
 */
export const usePurchaseShip = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof purchaseShip>>,
      TError,
      { data: PurchaseShipBody },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof purchaseShip>>,
  TError,
  { data: PurchaseShipBody },
  TContext
> => {
  const mutationOptions = getPurchaseShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve the details of a ship under your agent's ownership.
 * @summary Get Ship
 */
export const getMyShip = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetMyShip200>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}`,
    },
    options,
  );
};

export const getGetMyShipQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}`] as const;
};

export const getGetMyShipQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyShipQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyShip>>> = ({
    signal,
  }) => getMyShip(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getMyShip>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetMyShipQueryError = ErrorType<unknown>;
export type GetMyShipQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyShip>>
>;

export function useGetMyShip<
  TData = Awaited<ReturnType<typeof getMyShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShip>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyShip>>,
          TError,
          Awaited<ReturnType<typeof getMyShip>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyShip<
  TData = Awaited<ReturnType<typeof getMyShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShip>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyShip>>,
          TError,
          Awaited<ReturnType<typeof getMyShip>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyShip<
  TData = Awaited<ReturnType<typeof getMyShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Ship
 */

export function useGetMyShip<
  TData = Awaited<ReturnType<typeof getMyShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMyShipQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve the cargo of a ship under your agent's ownership.
 * @summary Get Ship Cargo
 */
export const getMyShipCargo = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetMyShipCargo200>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/cargo`,
    },
    options,
  );
};

export const getGetMyShipCargoQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}/cargo`] as const;
};

export const getGetMyShipCargoQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyShipCargo>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShipCargo>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyShipCargoQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyShipCargo>>> = ({
    signal,
  }) => getMyShipCargo(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyShipCargo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyShipCargoQueryError = ErrorType<unknown>;
export type GetMyShipCargoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyShipCargo>>
>;

export function useGetMyShipCargo<
  TData = Awaited<ReturnType<typeof getMyShipCargo>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShipCargo>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyShipCargo>>,
          TError,
          Awaited<ReturnType<typeof getMyShipCargo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyShipCargo<
  TData = Awaited<ReturnType<typeof getMyShipCargo>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShipCargo>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyShipCargo>>,
          TError,
          Awaited<ReturnType<typeof getMyShipCargo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyShipCargo<
  TData = Awaited<ReturnType<typeof getMyShipCargo>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShipCargo>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Ship Cargo
 */

export function useGetMyShipCargo<
  TData = Awaited<ReturnType<typeof getMyShipCargo>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyShipCargo>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMyShipCargoQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Attempt to move your ship into orbit at its current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.

Orbiting ships are able to do actions that require the ship to be above surface such as navigating or extracting, but cannot access elements in their current waypoint, such as the market or a shipyard.

The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
 * @summary Orbit Ship
 */
export const orbitShip = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<OrbitShip200>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/orbit`,
    },
    options,
  );
};

export const getOrbitShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof orbitShip>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof orbitShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['orbitShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof orbitShip>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return orbitShip(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrbitShipMutationError = ErrorType<unknown>;

export type OrbitShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof orbitShip>>
>;

/**
 * @summary Orbit Ship
 */
export const useOrbitShip = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof orbitShip>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof orbitShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getOrbitShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request. In order to be able to refine, a ship must have goods that can be refined and have installed a `Refinery` module that can refine it.

When refining, 100 basic goods will be converted into 10 processed goods.
 * @summary Ship Refine
 */
export const shipRefine = (
  shipSymbol: string,
  shipRefineBody: ShipRefineBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<ShipRefine201>(
    {
      data: shipRefineBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/refine`,
    },
    options,
  );
};

export const getShipRefineMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof shipRefine>>,
    TError,
    { data: ShipRefineBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof shipRefine>>,
  TError,
  { data: ShipRefineBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['shipRefine'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof shipRefine>>,
    { data: ShipRefineBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return shipRefine(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ShipRefineMutationBody = ShipRefineBody;
export type ShipRefineMutationError = ErrorType<unknown>;
export type ShipRefineMutationResult = NonNullable<
  Awaited<ReturnType<typeof shipRefine>>
>;

/**
 * @summary Ship Refine
 */
export const useShipRefine = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof shipRefine>>,
      TError,
      { data: ShipRefineBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof shipRefine>>,
  TError,
  { data: ShipRefineBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getShipRefineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Command a ship to chart the waypoint at its current location.

Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden until they have been charted by a ship.

Charting a waypoint will record your agent as the one who created the chart, and all other agents would also be able to see the waypoint's traits. Charting a waypoint gives you a one time reward of credits based on the rarity of the waypoint's traits.
 * @summary Create Chart
 */
export const createChart = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<CreateChart201>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/chart`,
    },
    options,
  );
};

export const getCreateChartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createChart>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createChart>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['createChart'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createChart>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return createChart(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateChartMutationError = ErrorType<unknown>;

export type CreateChartMutationResult = NonNullable<
  Awaited<ReturnType<typeof createChart>>
>;

/**
 * @summary Create Chart
 */
export const useCreateChart = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createChart>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createChart>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getCreateChartMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve the details of your ship's reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.

Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.

Response returns a 204 status code (no-content) when the ship has no cooldown.
 * @summary Get Ship Cooldown
 */
export const getShipCooldown = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetShipCooldown200 | void>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/cooldown`,
    },
    options,
  );
};

export const getGetShipCooldownQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}/cooldown`] as const;
};

export const getGetShipCooldownQueryOptions = <
  TData = Awaited<ReturnType<typeof getShipCooldown>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getShipCooldown>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetShipCooldownQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShipCooldown>>> = ({
    signal,
  }) => getShipCooldown(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getShipCooldown>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetShipCooldownQueryError = ErrorType<unknown>;
export type GetShipCooldownQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShipCooldown>>
>;

export function useGetShipCooldown<
  TData = Awaited<ReturnType<typeof getShipCooldown>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getShipCooldown>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShipCooldown>>,
          TError,
          Awaited<ReturnType<typeof getShipCooldown>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetShipCooldown<
  TData = Awaited<ReturnType<typeof getShipCooldown>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getShipCooldown>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShipCooldown>>,
          TError,
          Awaited<ReturnType<typeof getShipCooldown>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetShipCooldown<
  TData = Awaited<ReturnType<typeof getShipCooldown>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getShipCooldown>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Ship Cooldown
 */

export function useGetShipCooldown<
  TData = Awaited<ReturnType<typeof getShipCooldown>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getShipCooldown>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetShipCooldownQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Attempt to dock your ship at its current location. Docking will only succeed if your ship is capable of docking at the time of the request.

Docked ships can access elements in their current location, such as the market or a shipyard, but cannot do actions that require the ship to be above surface such as navigating or extracting.

The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
 * @summary Dock Ship
 */
export const dockShip = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<DockShip200>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/dock`,
    },
    options,
  );
};

export const getDockShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof dockShip>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof dockShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['dockShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof dockShip>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return dockShip(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DockShipMutationError = ErrorType<unknown>;

export type DockShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof dockShip>>
>;

/**
 * @summary Dock Ship
 */
export const useDockShip = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof dockShip>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof dockShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getDockShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on specific types of deposits from the extracted location. When ships extract using this survey, they are guaranteed to procure a high amount of one of the goods in the survey.

In order to use a survey, send the entire survey details in the body of the extract request.

Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.

Your ship will enter a cooldown after surveying in which it is unable to perform certain actions. Surveys will eventually expire after a period of time or will be exhausted after being extracted several times based on the survey's size. Multiple ships can use the same survey for extraction.

A ship must have the `Surveyor` mount installed in order to use this function.
 * @summary Create Survey
 */
export const createSurvey = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<CreateSurvey201>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/survey`,
    },
    options,
  );
};

export const getCreateSurveyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSurvey>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSurvey>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['createSurvey'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSurvey>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return createSurvey(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSurveyMutationError = ErrorType<unknown>;

export type CreateSurveyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSurvey>>
>;

/**
 * @summary Create Survey
 */
export const useCreateSurvey = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSurvey>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSurvey>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getCreateSurveyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship. Send an optional survey as the payload to target specific yields.

The ship must be in orbit to be able to extract and must have mining equipments installed that can extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for ore-based goods.

The survey property is now deprecated. See the `extract/survey` endpoint for more details.
 * @summary Extract Resources
 */
export const extractResources = (
  shipSymbol: string,
  extractResourcesBody: ExtractResourcesBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<ExtractResources201>(
    {
      data: extractResourcesBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/extract`,
    },
    options,
  );
};

export const getExtractResourcesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof extractResources>>,
    TError,
    { data: ExtractResourcesBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof extractResources>>,
  TError,
  { data: ExtractResourcesBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['extractResources'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof extractResources>>,
    { data: ExtractResourcesBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return extractResources(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExtractResourcesMutationBody = ExtractResourcesBody;
export type ExtractResourcesMutationError = ErrorType<unknown>;
export type ExtractResourcesMutationResult = NonNullable<
  Awaited<ReturnType<typeof extractResources>>
>;

/**
 * @summary Extract Resources
 */
export const useExtractResources = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof extractResources>>,
      TError,
      { data: ExtractResourcesBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof extractResources>>,
  TError,
  { data: ExtractResourcesBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getExtractResourcesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Siphon gases or other resources from gas giants.

The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor installed.
 * @summary Siphon Resources
 */
export const siphonResources = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<SiphonResources201>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/siphon`,
    },
    options,
  );
};

export const getSiphonResourcesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof siphonResources>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof siphonResources>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['siphonResources'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof siphonResources>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return siphonResources(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SiphonResourcesMutationError = ErrorType<unknown>;

export type SiphonResourcesMutationResult = NonNullable<
  Awaited<ReturnType<typeof siphonResources>>
>;

/**
 * @summary Siphon Resources
 */
export const useSiphonResources = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof siphonResources>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof siphonResources>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getSiphonResourcesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the payload, which allows your ship to extract specific yields.

Send the full survey object as the payload which will be validated according to the signature. If the signature is invalid, or any properties of the survey are changed, the request will fail.
 * @summary Extract Resources with Survey
 */
export const extractResourcesWithSurvey = (
  shipSymbol: string,
  survey: Survey,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<ExtractResourcesWithSurvey201>(
    {
      data: survey,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/extract/survey`,
    },
    options,
  );
};

export const getExtractResourcesWithSurveyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof extractResourcesWithSurvey>>,
    TError,
    { data: Survey; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof extractResourcesWithSurvey>>,
  TError,
  { data: Survey; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['extractResourcesWithSurvey'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof extractResourcesWithSurvey>>,
    { data: Survey; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return extractResourcesWithSurvey(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExtractResourcesWithSurveyMutationBody = Survey;
export type ExtractResourcesWithSurveyMutationError = ErrorType<unknown>;
export type ExtractResourcesWithSurveyMutationResult = NonNullable<
  Awaited<ReturnType<typeof extractResourcesWithSurvey>>
>;

/**
 * @summary Extract Resources with Survey
 */
export const useExtractResourcesWithSurvey = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof extractResourcesWithSurvey>>,
      TError,
      { data: Survey; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof extractResourcesWithSurvey>>,
  TError,
  { data: Survey; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getExtractResourcesWithSurveyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Jettison cargo from your ship's cargo hold.
 * @summary Jettison Cargo
 */
export const jettison = (
  shipSymbol: string,
  jettisonBody: JettisonBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<Jettison200>(
    {
      data: jettisonBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/jettison`,
    },
    options,
  );
};

export const getJettisonMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jettison>>,
    TError,
    { data: JettisonBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jettison>>,
  TError,
  { data: JettisonBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['jettison'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jettison>>,
    { data: JettisonBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return jettison(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JettisonMutationBody = JettisonBody;
export type JettisonMutationError = ErrorType<unknown>;
export type JettisonMutationResult = NonNullable<
  Awaited<ReturnType<typeof jettison>>
>;

/**
 * @summary Jettison Cargo
 */
export const useJettison = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jettison>>,
      TError,
      { data: JettisonBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof jettison>>,
  TError,
  { data: JettisonBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getJettisonMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a jump.

A unit of antimatter is purchased and consumed from the market when jumping. The price of antimatter is determined by the market and is subject to change. A ship can only jump to connected waypoints
 * @summary Jump Ship
 */
export const jumpShip = (
  shipSymbol: string,
  jumpShipBody: JumpShipBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<JumpShip200>(
    {
      data: jumpShipBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/jump`,
    },
    options,
  );
};

export const getJumpShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jumpShip>>,
    TError,
    { data: JumpShipBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jumpShip>>,
  TError,
  { data: JumpShipBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['jumpShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jumpShip>>,
    { data: JumpShipBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return jumpShip(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JumpShipMutationBody = JumpShipBody;
export type JumpShipMutationError = ErrorType<unknown>;
export type JumpShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof jumpShip>>
>;

/**
 * @summary Jump Ship
 */
export const useJumpShip = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jumpShip>>,
      TError,
      { data: JumpShipBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof jumpShip>>,
  TError,
  { data: JumpShipBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getJumpShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Navigate to a target destination. The ship must be in orbit to use this function. The destination waypoint must be within the same system as the ship's current location. Navigating will consume the necessary fuel from the ship's manifest based on the distance to the target waypoint.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it's destination.

To travel between systems, see the ship's Warp or Jump actions.
 * @summary Navigate Ship
 */
export const navigateShip = (
  shipSymbol: string,
  navigateShipBody: NavigateShipBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<NavigateShip200>(
    {
      data: navigateShipBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/navigate`,
    },
    options,
  );
};

export const getNavigateShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof navigateShip>>,
    TError,
    { data: NavigateShipBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof navigateShip>>,
  TError,
  { data: NavigateShipBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['navigateShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof navigateShip>>,
    { data: NavigateShipBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return navigateShip(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NavigateShipMutationBody = NavigateShipBody;
export type NavigateShipMutationError = ErrorType<unknown>;
export type NavigateShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof navigateShip>>
>;

/**
 * @summary Navigate Ship
 */
export const useNavigateShip = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof navigateShip>>,
      TError,
      { data: NavigateShipBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof navigateShip>>,
  TError,
  { data: NavigateShipBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getNavigateShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update the nav configuration of a ship.

Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel consumption.
 * @summary Patch Ship Nav
 */
export const patchShipNav = (
  shipSymbol: string,
  patchShipNavBody: PatchShipNavBody,
  options?: SecondParameter<typeof clientInstance>,
) => {
  return clientInstance<PatchShipNav200>(
    {
      data: patchShipNavBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'PATCH',
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/nav`,
    },
    options,
  );
};

export const getPatchShipNavMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchShipNav>>,
    TError,
    { data: PatchShipNavBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchShipNav>>,
  TError,
  { data: PatchShipNavBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['patchShipNav'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchShipNav>>,
    { data: PatchShipNavBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return patchShipNav(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchShipNavMutationBody = PatchShipNavBody;
export type PatchShipNavMutationError = ErrorType<unknown>;
export type PatchShipNavMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchShipNav>>
>;

/**
 * @summary Patch Ship Nav
 */
export const usePatchShipNav = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchShipNav>>,
      TError,
      { data: PatchShipNavBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchShipNav>>,
  TError,
  { data: PatchShipNavBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getPatchShipNavMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get the current nav status of a ship.
 * @summary Get Ship Nav
 */
export const getShipNav = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetShipNav200>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/nav`,
    },
    options,
  );
};

export const getGetShipNavQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}/nav`] as const;
};

export const getGetShipNavQueryOptions = <
  TData = Awaited<ReturnType<typeof getShipNav>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipNav>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetShipNavQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShipNav>>> = ({
    signal,
  }) => getShipNav(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getShipNav>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetShipNavQueryError = ErrorType<unknown>;
export type GetShipNavQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShipNav>>
>;

export function useGetShipNav<
  TData = Awaited<ReturnType<typeof getShipNav>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipNav>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShipNav>>,
          TError,
          Awaited<ReturnType<typeof getShipNav>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetShipNav<
  TData = Awaited<ReturnType<typeof getShipNav>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipNav>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShipNav>>,
          TError,
          Awaited<ReturnType<typeof getShipNav>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetShipNav<
  TData = Awaited<ReturnType<typeof getShipNav>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipNav>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Ship Nav
 */

export function useGetShipNav<
  TData = Awaited<ReturnType<typeof getShipNav>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipNav>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetShipNavQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Warp your ship to a target destination in another system. The ship must be in orbit to use this function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel from the ship's manifest.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at its destination.
 * @summary Warp Ship
 */
export const warpShip = (
  shipSymbol: string,
  warpShipBody: WarpShipBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<WarpShip200>(
    {
      data: warpShipBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/warp`,
    },
    options,
  );
};

export const getWarpShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof warpShip>>,
    TError,
    { data: WarpShipBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof warpShip>>,
  TError,
  { data: WarpShipBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['warpShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof warpShip>>,
    { data: WarpShipBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return warpShip(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WarpShipMutationBody = WarpShipBody;
export type WarpShipMutationError = ErrorType<unknown>;
export type WarpShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof warpShip>>
>;

/**
 * @summary Warp Ship
 */
export const useWarpShip = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof warpShip>>,
      TError,
      { data: WarpShipBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof warpShip>>,
  TError,
  { data: WarpShipBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getWarpShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint that has the `Marketplace` trait in order to use this function.
 * @summary Sell Cargo
 */
export const sellCargo = (
  shipSymbol: string,
  sellCargoBody: SellCargoBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<SellCargo201>(
    {
      data: sellCargoBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/sell`,
    },
    options,
  );
};

export const getSellCargoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sellCargo>>,
    TError,
    { data: SellCargoBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sellCargo>>,
  TError,
  { data: SellCargoBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['sellCargo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sellCargo>>,
    { data: SellCargoBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return sellCargo(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SellCargoMutationBody = SellCargoBody;
export type SellCargoMutationError = ErrorType<unknown>;
export type SellCargoMutationResult = NonNullable<
  Awaited<ReturnType<typeof sellCargo>>
>;

/**
 * @summary Sell Cargo
 */
export const useSellCargo = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sellCargo>>,
      TError,
      { data: SellCargoBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sellCargo>>,
  TError,
  { data: SellCargoBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getSellCargoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Scan for nearby systems, retrieving information on the systems' distance from the ship and their waypoints. Requires a ship to have the `Sensor Array` mount installed to use.

The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
 * @summary Scan Systems
 */
export const createShipSystemScan = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<CreateShipSystemScan201>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/scan/systems`,
    },
    options,
  );
};

export const getCreateShipSystemScanMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createShipSystemScan>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createShipSystemScan>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['createShipSystemScan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createShipSystemScan>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return createShipSystemScan(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateShipSystemScanMutationError = ErrorType<unknown>;

export type CreateShipSystemScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof createShipSystemScan>>
>;

/**
 * @summary Scan Systems
 */
export const useCreateShipSystemScan = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createShipSystemScan>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createShipSystemScan>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getCreateShipSystemScanMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints' traits.

Requires a ship to have the `Sensor Array` mount installed to use.

The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
 * @summary Scan Waypoints
 */
export const createShipWaypointScan = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<CreateShipWaypointScan201>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/scan/waypoints`,
    },
    options,
  );
};

export const getCreateShipWaypointScanMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createShipWaypointScan>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createShipWaypointScan>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['createShipWaypointScan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createShipWaypointScan>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return createShipWaypointScan(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateShipWaypointScanMutationError = ErrorType<unknown>;

export type CreateShipWaypointScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof createShipWaypointScan>>
>;

/**
 * @summary Scan Waypoints
 */
export const useCreateShipWaypointScan = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createShipWaypointScan>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createShipWaypointScan>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getCreateShipWaypointScanMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Scan for nearby ships, retrieving information for all ships in range.

Requires a ship to have the `Sensor Array` mount installed to use.

The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
 * @summary Scan Ships
 */
export const createShipShipScan = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<CreateShipShipScan201>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/scan/ships`,
    },
    options,
  );
};

export const getCreateShipShipScanMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createShipShipScan>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createShipShipScan>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['createShipShipScan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createShipShipScan>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return createShipShipScan(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateShipShipScanMutationError = ErrorType<unknown>;

export type CreateShipShipScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof createShipShipScan>>
>;

/**
 * @summary Scan Ships
 */
export const useCreateShipShipScan = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createShipShipScan>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createShipShipScan>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getCreateShipShipScanMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Refuel your ship by buying fuel from the local market.

Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must be selling fuel in order to refuel.

Each fuel bought from the market replenishes 100 units in your ship's fuel.

Ships will always be refuel to their frame's maximum fuel capacity when using this action.
 * @summary Refuel Ship
 */
export const refuelShip = (
  shipSymbol: string,
  refuelShipBody: RefuelShipBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<RefuelShip200>(
    {
      data: refuelShipBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/refuel`,
    },
    options,
  );
};

export const getRefuelShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refuelShip>>,
    TError,
    { data: RefuelShipBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refuelShip>>,
  TError,
  { data: RefuelShipBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['refuelShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refuelShip>>,
    { data: RefuelShipBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return refuelShip(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefuelShipMutationBody = RefuelShipBody;
export type RefuelShipMutationError = ErrorType<unknown>;
export type RefuelShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof refuelShip>>
>;

/**
 * @summary Refuel Ship
 */
export const useRefuelShip = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refuelShip>>,
      TError,
      { data: RefuelShipBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof refuelShip>>,
  TError,
  { data: RefuelShipBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getRefuelShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Purchase cargo from a market.

The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling a good to be able to purchase it.

The maximum amount of units of a good that can be purchased in each transaction are denoted by the `tradeVolume` value of the good, which can be viewed by using the Get Market action.

Purchased goods are added to the ship's cargo hold.
 * @summary Purchase Cargo
 */
export const purchaseCargo = (
  shipSymbol: string,
  purchaseCargoBody: PurchaseCargoBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<PurchaseCargo201>(
    {
      data: purchaseCargoBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/purchase`,
    },
    options,
  );
};

export const getPurchaseCargoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof purchaseCargo>>,
    TError,
    { data: PurchaseCargoBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof purchaseCargo>>,
  TError,
  { data: PurchaseCargoBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['purchaseCargo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof purchaseCargo>>,
    { data: PurchaseCargoBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return purchaseCargo(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PurchaseCargoMutationBody = PurchaseCargoBody;
export type PurchaseCargoMutationError = ErrorType<unknown>;
export type PurchaseCargoMutationResult = NonNullable<
  Awaited<ReturnType<typeof purchaseCargo>>
>;

/**
 * @summary Purchase Cargo
 */
export const usePurchaseCargo = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof purchaseCargo>>,
      TError,
      { data: PurchaseCargoBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof purchaseCargo>>,
  TError,
  { data: PurchaseCargoBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getPurchaseCargoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Transfer cargo between ships.

The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold the additional cargo after the transfer is complete. Both ships also must be in the same state, either both are docked or both are orbiting.

The response body's cargo shows the cargo of the transferring ship after the transfer is complete.
 * @summary Transfer Cargo
 */
export const transferCargo = (
  shipSymbol: string,
  transferCargoBody: TransferCargoBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<TransferCargo200>(
    {
      data: transferCargoBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/transfer`,
    },
    options,
  );
};

export const getTransferCargoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transferCargo>>,
    TError,
    { data: TransferCargoBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof transferCargo>>,
  TError,
  { data: TransferCargoBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['transferCargo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof transferCargo>>,
    { data: TransferCargoBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return transferCargo(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TransferCargoMutationBody = TransferCargoBody;
export type TransferCargoMutationError = ErrorType<unknown>;
export type TransferCargoMutationResult = NonNullable<
  Awaited<ReturnType<typeof transferCargo>>
>;

/**
 * @summary Transfer Cargo
 */
export const useTransferCargo = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof transferCargo>>,
      TError,
      { data: TransferCargoBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof transferCargo>>,
  TError,
  { data: TransferCargoBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getTransferCargoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Negotiate a new contract with the HQ.

In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.

Once a contract is negotiated, it is added to the list of contracts offered to the agent, which the agent can then accept. 

The ship must be present at any waypoint with a faction present to negotiate a contract with that faction.
 * @summary Negotiate Contract
 */
export const negotiateContract = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<NegotiateContract201>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/negotiate/contract`,
    },
    options,
  );
};

export const getNegotiateContractMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof negotiateContract>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof negotiateContract>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['negotiateContract'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof negotiateContract>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return negotiateContract(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NegotiateContractMutationError = ErrorType<unknown>;

export type NegotiateContractMutationResult = NonNullable<
  Awaited<ReturnType<typeof negotiateContract>>
>;

/**
 * @summary Negotiate Contract
 */
export const useNegotiateContract = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof negotiateContract>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof negotiateContract>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getNegotiateContractMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get the mounts installed on a ship.
 * @summary Get Mounts
 */
export const getMounts = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetMounts200>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/mounts`,
    },
    options,
  );
};

export const getGetMountsQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}/mounts`] as const;
};

export const getGetMountsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMounts>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMounts>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMountsQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMounts>>> = ({
    signal,
  }) => getMounts(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getMounts>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetMountsQueryError = ErrorType<unknown>;
export type GetMountsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMounts>>
>;

export function useGetMounts<
  TData = Awaited<ReturnType<typeof getMounts>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMounts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMounts>>,
          TError,
          Awaited<ReturnType<typeof getMounts>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMounts<
  TData = Awaited<ReturnType<typeof getMounts>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMounts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMounts>>,
          TError,
          Awaited<ReturnType<typeof getMounts>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMounts<
  TData = Awaited<ReturnType<typeof getMounts>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMounts>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Mounts
 */

export function useGetMounts<
  TData = Awaited<ReturnType<typeof getMounts>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMounts>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMountsQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Install a mount on a ship.

In order to install a mount, the ship must be docked and located in a waypoint that has a `Shipyard` trait. The ship also must have the mount to install in its cargo hold.

An installation fee will be deduced by the Shipyard for installing the mount on the ship. 
 * @summary Install Mount
 */
export const installMount = (
  shipSymbol: string,
  installMountBody: InstallMountBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<InstallMount201>(
    {
      data: installMountBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/mounts/install`,
    },
    options,
  );
};

export const getInstallMountMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof installMount>>,
    TError,
    { data: InstallMountBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof installMount>>,
  TError,
  { data: InstallMountBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['installMount'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof installMount>>,
    { data: InstallMountBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return installMount(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type InstallMountMutationBody = InstallMountBody;
export type InstallMountMutationError = ErrorType<unknown>;
export type InstallMountMutationResult = NonNullable<
  Awaited<ReturnType<typeof installMount>>
>;

/**
 * @summary Install Mount
 */
export const useInstallMount = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof installMount>>,
      TError,
      { data: InstallMountBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof installMount>>,
  TError,
  { data: InstallMountBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getInstallMountMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Remove a mount from a ship.

The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired mount that it wish to remove installed.

A removal fee will be deduced from the agent by the Shipyard.
 * @summary Remove Mount
 */
export const removeMount = (
  shipSymbol: string,
  removeMountBody: RemoveMountBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<RemoveMount201>(
    {
      data: removeMountBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/mounts/remove`,
    },
    options,
  );
};

export const getRemoveMountMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeMount>>,
    TError,
    { data: RemoveMountBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeMount>>,
  TError,
  { data: RemoveMountBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['removeMount'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeMount>>,
    { data: RemoveMountBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return removeMount(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveMountMutationBody = RemoveMountBody;
export type RemoveMountMutationError = ErrorType<unknown>;
export type RemoveMountMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeMount>>
>;

/**
 * @summary Remove Mount
 */
export const useRemoveMount = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeMount>>,
      TError,
      { data: RemoveMountBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeMount>>,
  TError,
  { data: RemoveMountBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getRemoveMountMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get the amount of value that will be returned when scrapping a ship.
 * @summary Get Scrap Ship
 */
export const getScrapShip = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetScrapShip200>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/scrap`,
    },
    options,
  );
};

export const getGetScrapShipQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}/scrap`] as const;
};

export const getGetScrapShipQueryOptions = <
  TData = Awaited<ReturnType<typeof getScrapShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getScrapShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetScrapShipQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getScrapShip>>> = ({
    signal,
  }) => getScrapShip(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getScrapShip>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetScrapShipQueryError = ErrorType<unknown>;
export type GetScrapShipQueryResult = NonNullable<
  Awaited<ReturnType<typeof getScrapShip>>
>;

export function useGetScrapShip<
  TData = Awaited<ReturnType<typeof getScrapShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getScrapShip>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScrapShip>>,
          TError,
          Awaited<ReturnType<typeof getScrapShip>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScrapShip<
  TData = Awaited<ReturnType<typeof getScrapShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getScrapShip>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScrapShip>>,
          TError,
          Awaited<ReturnType<typeof getScrapShip>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScrapShip<
  TData = Awaited<ReturnType<typeof getScrapShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getScrapShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Scrap Ship
 */

export function useGetScrapShip<
  TData = Awaited<ReturnType<typeof getScrapShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getScrapShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetScrapShipQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Scrap a ship, removing it from the game and returning a portion of the ship's value to the agent. The ship must be docked in a waypoint that has the `Shipyard` trait in order to use this function. To preview the amount of value that will be returned, use the Get Ship action.
 * @summary Scrap Ship
 */
export const scrapShip = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<ScrapShip200>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/scrap`,
    },
    options,
  );
};

export const getScrapShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof scrapShip>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof scrapShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['scrapShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scrapShip>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return scrapShip(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScrapShipMutationError = ErrorType<unknown>;

export type ScrapShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof scrapShip>>
>;

/**
 * @summary Scrap Ship
 */
export const useScrapShip = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof scrapShip>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof scrapShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getScrapShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get the cost of repairing a ship.
 * @summary Get Repair Ship
 */
export const getRepairShip = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetRepairShip200>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/repair`,
    },
    options,
  );
};

export const getGetRepairShipQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}/repair`] as const;
};

export const getGetRepairShipQueryOptions = <
  TData = Awaited<ReturnType<typeof getRepairShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRepairShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRepairShipQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRepairShip>>> = ({
    signal,
  }) => getRepairShip(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRepairShip>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRepairShipQueryError = ErrorType<unknown>;
export type GetRepairShipQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRepairShip>>
>;

export function useGetRepairShip<
  TData = Awaited<ReturnType<typeof getRepairShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRepairShip>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRepairShip>>,
          TError,
          Awaited<ReturnType<typeof getRepairShip>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRepairShip<
  TData = Awaited<ReturnType<typeof getRepairShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRepairShip>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRepairShip>>,
          TError,
          Awaited<ReturnType<typeof getRepairShip>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRepairShip<
  TData = Awaited<ReturnType<typeof getRepairShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRepairShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Repair Ship
 */

export function useGetRepairShip<
  TData = Awaited<ReturnType<typeof getRepairShip>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRepairShip>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRepairShipQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Repair a ship, restoring the ship to maximum condition. The ship must be docked at a waypoint that has the `Shipyard` trait in order to use this function. To preview the cost of repairing the ship, use the Get action.
 * @summary Repair Ship
 */
export const repairShip = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<RepairShip200>(
    {
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/repair`,
    },
    options,
  );
};

export const getRepairShipMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof repairShip>>,
    TError,
    { shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof repairShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationKey = ['repairShip'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof repairShip>>,
    { shipSymbol: string }
  > = (props) => {
    const { shipSymbol } = props ?? {};

    return repairShip(shipSymbol, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RepairShipMutationError = ErrorType<unknown>;

export type RepairShipMutationResult = NonNullable<
  Awaited<ReturnType<typeof repairShip>>
>;

/**
 * @summary Repair Ship
 */
export const useRepairShip = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof repairShip>>,
      TError,
      { shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof repairShip>>,
  TError,
  { shipSymbol: string },
  TContext
> => {
  const mutationOptions = getRepairShipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get the modules installed on a ship.
 * @summary Get Ship Modules
 */
export const getShipModules = (
  shipSymbol: string,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetShipModules200>(
    {
      method: 'GET',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/modules`,
    },
    options,
  );
};

export const getGetShipModulesQueryKey = (shipSymbol?: string) => {
  return [`/my/ships/${shipSymbol}/modules`] as const;
};

export const getGetShipModulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getShipModules>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipModules>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetShipModulesQueryKey(shipSymbol);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShipModules>>> = ({
    signal,
  }) => getShipModules(shipSymbol, requestOptions, signal);

  return {
    enabled: !!shipSymbol,
    queryFn,
    queryKey,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getShipModules>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetShipModulesQueryError = ErrorType<unknown>;
export type GetShipModulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShipModules>>
>;

export function useGetShipModules<
  TData = Awaited<ReturnType<typeof getShipModules>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipModules>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShipModules>>,
          TError,
          Awaited<ReturnType<typeof getShipModules>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetShipModules<
  TData = Awaited<ReturnType<typeof getShipModules>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipModules>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShipModules>>,
          TError,
          Awaited<ReturnType<typeof getShipModules>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetShipModules<
  TData = Awaited<ReturnType<typeof getShipModules>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipModules>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Ship Modules
 */

export function useGetShipModules<
  TData = Awaited<ReturnType<typeof getShipModules>>,
  TError = ErrorType<unknown>,
>(
  shipSymbol: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getShipModules>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetShipModulesQueryOptions(shipSymbol, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Install a module on a ship. The module must be in your cargo.
 * @summary Install Ship Module
 */
export const installShipModule = (
  shipSymbol: string,
  installShipModuleBody: InstallShipModuleBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<InstallShipModule201>(
    {
      data: installShipModuleBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/modules/install`,
    },
    options,
  );
};

export const getInstallShipModuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof installShipModule>>,
    TError,
    { data: InstallShipModuleBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof installShipModule>>,
  TError,
  { data: InstallShipModuleBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['installShipModule'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof installShipModule>>,
    { data: InstallShipModuleBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return installShipModule(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type InstallShipModuleMutationBody = InstallShipModuleBody;
export type InstallShipModuleMutationError = ErrorType<unknown>;
export type InstallShipModuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof installShipModule>>
>;

/**
 * @summary Install Ship Module
 */
export const useInstallShipModule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof installShipModule>>,
      TError,
      { data: InstallShipModuleBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof installShipModule>>,
  TError,
  { data: InstallShipModuleBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getInstallShipModuleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Remove a module from a ship. The module will be placed in cargo.
 * @summary Remove Ship Module
 */
export const removeShipModule = (
  shipSymbol: string,
  removeShipModuleBody: RemoveShipModuleBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<RemoveShipModule201>(
    {
      data: removeShipModuleBody,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      signal,
      url: `/my/ships/${encodeURIComponent(String(shipSymbol))}/modules/remove`,
    },
    options,
  );
};

export const getRemoveShipModuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeShipModule>>,
    TError,
    { data: RemoveShipModuleBody; shipSymbol: string },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeShipModule>>,
  TError,
  { data: RemoveShipModuleBody; shipSymbol: string },
  TContext
> => {
  const mutationKey = ['removeShipModule'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeShipModule>>,
    { data: RemoveShipModuleBody; shipSymbol: string }
  > = (props) => {
    const { data, shipSymbol } = props ?? {};

    return removeShipModule(shipSymbol, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveShipModuleMutationBody = RemoveShipModuleBody;
export type RemoveShipModuleMutationError = ErrorType<unknown>;
export type RemoveShipModuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeShipModule>>
>;

/**
 * @summary Remove Ship Module
 */
export const useRemoveShipModule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeShipModule>>,
      TError,
      { data: RemoveShipModuleBody; shipSymbol: string },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeShipModule>>,
  TError,
  { data: RemoveShipModuleBody; shipSymbol: string },
  TContext
> => {
  const mutationOptions = getRemoveShipModuleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
