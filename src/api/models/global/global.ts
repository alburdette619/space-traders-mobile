/**
 * Generated by orval v8.0.0-rc.0 üç∫
 * Do not edit manually.
 * SpaceTraders API
 * SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.

The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.

```json http
{
  "method": "GET",
  "url": "https://api.spacetraders.io/v2",
}
```

Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.

We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.



 * OpenAPI spec version: 2.3.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type { GetStatus200 } from "../getStatus200";

import type { Register201 } from "../register201";

import type { RegisterBody } from "../registerBody";

import { clientInstance } from "../../client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Return the status of the game server.
This also includes a few global elements, such as announcements, server reset dates and leaderboards.
 * @summary Get Status
 */
export const getStatus = (
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<GetStatus200>(
    { url: `/`, method: "GET", signal },
    options,
  );
};

export const getGetStatusQueryKey = () => {
  return [`/`] as const;
};

export const getGetStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getStatus>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData>
  >;
  request?: SecondParameter<typeof clientInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatus>>> = ({
    signal,
  }) => getStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStatus>>
>;
export type GetStatusQueryError = unknown;

export function useGetStatus<
  TData = Awaited<ReturnType<typeof getStatus>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatus>>,
          TError,
          Awaited<ReturnType<typeof getStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStatus<
  TData = Awaited<ReturnType<typeof getStatus>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatus>>,
          TError,
          Awaited<ReturnType<typeof getStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStatus<
  TData = Awaited<ReturnType<typeof getStatus>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Status
 */

export function useGetStatus<
  TData = Awaited<ReturnType<typeof getStatus>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData>
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetStatusQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new agent and ties it to an account. 
The agent symbol must consist of a 3-14 character string, and will be used to represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.

This new agent will be tied to a starting faction of your choice, which determines your starting location, and will be granted an authorization token, a contract with their starting faction, a command ship that can fly across space with advanced capabilities, a small probe ship that can be used for reconnaissance, and 175,000 credits.

> #### Keep your token safe and secure
>
> Keep careful track of where you store your token. You can generate a new token from our account dashboard, but if someone else gains access to your token they will be able to use it to make API requests on your behalf until the end of the reset.

If you are new to SpaceTraders, It is recommended to register with the COSMIC faction, a faction that is well connected to the rest of the universe. After registering, you should try our interactive [quickstart guide](https://docs.spacetraders.io/quickstart/new-game) which will walk you through a few basic API requests in just a few minutes.
 * @summary Register New Agent
 */
export const register = (
  registerBody: RegisterBody,
  options?: SecondParameter<typeof clientInstance>,
  signal?: AbortSignal,
) => {
  return clientInstance<Register201>(
    {
      url: `/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: registerBody,
      signal,
    },
    options,
  );
};

export const getRegisterMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterBody },
    TContext
  >;
  request?: SecondParameter<typeof clientInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationKey = ["register"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: RegisterBody }
  > = (props) => {
    const { data } = props ?? {};

    return register(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof register>>
>;
export type RegisterMutationBody = RegisterBody;
export type RegisterMutationError = unknown;

/**
 * @summary Register New Agent
 */
export const useRegister = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register>>,
      TError,
      { data: RegisterBody },
      TContext
    >;
    request?: SecondParameter<typeof clientInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationOptions = getRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
